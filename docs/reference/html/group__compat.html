<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: Compatibility module</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.3 -->
<h1>Compatibility module</h1>This set of types and functions provides an API that is compatible to libsigc++-1.2.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal0.html">SigC::Signal0&lt;T_return, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal1.html">SigC::Signal1&lt;T_return, T_arg1, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal2.html">SigC::Signal2&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal3.html">SigC::Signal3&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal4.html">SigC::Signal4&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal5.html">SigC::Signal5&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal6.html">SigC::Signal6&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal7.html">SigC::Signal7&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0&lt;T_return&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1&lt;T_return, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2&lt;T_return, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3&lt;T_return, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot7.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
::<a class="el" href="structsigc_1_1connection.html">sigc::connection</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compat.html#g91f89ef3d156946196625c06de970957">SigC::Connection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convinience class for safe disconnection.  <a href="#g91f89ef3d156946196625c06de970957"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g91af9b19917042109ebd6a01009dfcd7">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a method and an object instance.  <a href="#g91af9b19917042109ebd6a01009dfcd7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gb1e0a43a66d818a52b29479c85531139">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a method and an object instance.  <a href="#gb1e0a43a66d818a52b29479c85531139"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g4c4822aeb56b6c748008226648791860">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a method and an object instance.  <a href="#g4c4822aeb56b6c748008226648791860"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gd8d25c2c7dd544a6b2b280e7e62e6048">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a method and an object instance.  <a href="#gd8d25c2c7dd544a6b2b280e7e62e6048"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gde17bd35ebbbdd4f7e81d64f723376f1">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a method and an object instance.  <a href="#gde17bd35ebbbdd4f7e81d64f723376f1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g81a5adc40307650a5cd89d375e0987ac">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a method and an object instance.  <a href="#g81a5adc40307650a5cd89d375e0987ac"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ge46071e505c2519a76993d3262904ef1">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a method and an object instance.  <a href="#ge46071e505c2519a76993d3262904ef1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot7&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g622d6dbceeade9a3bb4faeff3e5d5a8a">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a method and an object instance.  <a href="#g622d6dbceeade9a3bb4faeff3e5d5a8a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g75a6ff95d43b210d56f61264a56dc373">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const method and an object instance.  <a href="#g75a6ff95d43b210d56f61264a56dc373"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gdc3f898be979b722b25a4ad24668e3ab">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const method and an object instance.  <a href="#gdc3f898be979b722b25a4ad24668e3ab"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g2c46b761223b969cb7a63bc60d9b8249">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const method and an object instance.  <a href="#g2c46b761223b969cb7a63bc60d9b8249"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g09e1ce614750eb0dda785c2dcb0820a1">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const method and an object instance.  <a href="#g09e1ce614750eb0dda785c2dcb0820a1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g606334d30de15d8a9b2a4b9b3bd23f68">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const method and an object instance.  <a href="#g606334d30de15d8a9b2a4b9b3bd23f68"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g635b197d134d20e6593c59b02b17b361">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const method and an object instance.  <a href="#g635b197d134d20e6593c59b02b17b361"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gd49affd5459e463a7a2fc038d4e6614b">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const method and an object instance.  <a href="#gd49affd5459e463a7a2fc038d4e6614b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot7&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gaaa4e86a7f5efa0d68360725a9035e3a">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const method and an object instance.  <a href="#gaaa4e86a7f5efa0d68360725a9035e3a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt; T_return,<br>
 T_obj&amp; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g7246d6fa67ac9b66c913a35b93e18003">SigC::slot</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot1 that wraps a method.  <a href="#g7246d6fa67ac9b66c913a35b93e18003"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; T_return,<br>
 T_obj&amp;, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g3c952510d32d46cdfd2abf1128fc6d97">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot2 that wraps a method.  <a href="#g3c952510d32d46cdfd2abf1128fc6d97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g82b240878388eeecbaa7c279d955e807">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot3 that wraps a method.  <a href="#g82b240878388eeecbaa7c279d955e807"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g52eae75f30f433a7833e700ff25ac278">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot4 that wraps a method.  <a href="#g52eae75f30f433a7833e700ff25ac278"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g16e743368f8ee8868a2ebf185b75f056">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot5 that wraps a method.  <a href="#g16e743368f8ee8868a2ebf185b75f056"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g6c1842450bb4b8b99357df9c4b00cb7c">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot6 that wraps a method.  <a href="#g6c1842450bb4b8b99357df9c4b00cb7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot7&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gce1eff0e298e8d7cc580b827834607c7">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot7 that wraps a method.  <a href="#gce1eff0e298e8d7cc580b827834607c7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ge6e633fa340e3017871d86cb34367340">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a method and an object instance.  <a href="#ge6e633fa340e3017871d86cb34367340"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g3011c8f9efec0dc294994982f28fe520">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a method and an object instance.  <a href="#g3011c8f9efec0dc294994982f28fe520"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gcc3e1f6e658c464968947e19a188a180">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a method and an object instance.  <a href="#gcc3e1f6e658c464968947e19a188a180"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g86024098d53519ffa31aed081c347f07">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a method and an object instance.  <a href="#g86024098d53519ffa31aed081c347f07"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gdbee3c6f5bf882d3d0283a0226db86e3">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a method and an object instance.  <a href="#gdbee3c6f5bf882d3d0283a0226db86e3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g3c6d334b182a0a41a094f59d815a5367">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a method and an object instance.  <a href="#g3c6d334b182a0a41a094f59d815a5367"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g9f2487af1f489d5c39e019e05b579d52">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a method and an object instance.  <a href="#g9f2487af1f489d5c39e019e05b579d52"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot7&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ga6cd5deb8723357f578c5f57b2079a4c">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a method and an object instance.  <a href="#ga6cd5deb8723357f578c5f57b2079a4c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g9bca6dad79e9b0cccb8550831324c06c">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const method and an object instance.  <a href="#g9bca6dad79e9b0cccb8550831324c06c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g107343642e204fb11d430487da95f832">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const method and an object instance.  <a href="#g107343642e204fb11d430487da95f832"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g8fab160f730b83efbd9a74a24106a95b">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const method and an object instance.  <a href="#g8fab160f730b83efbd9a74a24106a95b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g5dbe067d6c701ea6cacff393f9f240ba">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const method and an object instance.  <a href="#g5dbe067d6c701ea6cacff393f9f240ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g82d05033e2b2bee1ce03b1381c12da6b">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const method and an object instance.  <a href="#g82d05033e2b2bee1ce03b1381c12da6b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ga1bb9d6796c4e6c072cd83a9118307b9">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const method and an object instance.  <a href="#ga1bb9d6796c4e6c072cd83a9118307b9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g88e87cb153a459d61776de5dfcda3677">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const method and an object instance.  <a href="#g88e87cb153a459d61776de5dfcda3677"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot7&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gc47a32cf4be8bd49a9d1beef1e398f69">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const method and an object instance.  <a href="#gc47a32cf4be8bd49a9d1beef1e398f69"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g259877f1c067ad10514f07687f337f8b">SigC::slot</a> (T_return(* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that wraps an existing non-member function.  <a href="#g259877f1c067ad10514f07687f337f8b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gfacca4d95320191460b14c9e21852894">SigC::slot</a> (T_return(* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that wraps an existing non-member function.  <a href="#gfacca4d95320191460b14c9e21852894"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g0ac04ea07b8fa82f006a1c7ca8aca27d">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that wraps an existing non-member function.  <a href="#g0ac04ea07b8fa82f006a1c7ca8aca27d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g642ee7f310005080070b485ac453f141">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that wraps an existing non-member function.  <a href="#g642ee7f310005080070b485ac453f141"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g239f7cb0854b6174de6303c5b0df153d">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that wraps an existing non-member function.  <a href="#g239f7cb0854b6174de6303c5b0df153d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gc4b3fe13ba71b42b8013a8384b5c4d97">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that wraps an existing non-member function.  <a href="#gc4b3fe13ba71b42b8013a8384b5c4d97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gf525841f56ed2339c2fb64c7c77ffa44">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that wraps an existing non-member function.  <a href="#gf525841f56ed2339c2fb64c7c77ffa44"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot7&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g2d178de73e58532c261c79434eb80efb">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that wraps an existing non-member function.  <a href="#g2d178de73e58532c261c79434eb80efb"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This set of types and functions provides an API that is compatible to libsigc++-1.2. 
<p>
Some internal structures of libsigc++-1.2 are not available.<p>
All types and functions that are defined in namespace <a class="el" href="namespaceSigC.html">SigC</a> are deprecated. Use the new libsigc++2 API that is defined in namespace <a class="el" href="namespacesigc.html">sigc</a>. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g91f89ef3d156946196625c06de970957"></a><!-- doxytag: member="SigC::Connection" ref="g91f89ef3d156946196625c06de970957" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structsigc_1_1connection.html">sigc::connection</a> <a class="el" href="structsigc_1_1connection.html">SigC::Connection</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convinience class for safe disconnection. 
<p>
Iterators must not be used beyond the lifetime of the list they work on. A connection object can be created from a slot list iterator and may safely be used to disconnect the referred slot at any time (disconnect()). If the slot has already been destroyed, disconnect() does nothing. empty() or operator bool() can be used to test whether the connection is still active. The connection can be blocked (block(), unblock()).<p>
This is possible because the connection object gets notified when the referred slot dies (notify()).<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Use <a class="el" href="structsigc_1_1connection.html" title="Convinience class for safe disconnection.">sigc::connection</a> instead. </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g2d178de73e58532c261c79434eb80efb"></a><!-- doxytag: member="SigC::slot" ref="g2d178de73e58532c261c79434eb80efb" args="(T_return(*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf525841f56ed2339c2fb64c7c77ffa44"></a><!-- doxytag: member="SigC::slot" ref="gf525841f56ed2339c2fb64c7c77ffa44" args="(T_return(*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000116">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc4b3fe13ba71b42b8013a8384b5c4d97"></a><!-- doxytag: member="SigC::slot" ref="gc4b3fe13ba71b42b8013a8384b5c4d97" args="(T_return(*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000115">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g239f7cb0854b6174de6303c5b0df153d"></a><!-- doxytag: member="SigC::slot" ref="g239f7cb0854b6174de6303c5b0df153d" args="(T_return(*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000114">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g642ee7f310005080070b485ac453f141"></a><!-- doxytag: member="SigC::slot" ref="g642ee7f310005080070b485ac453f141" args="(T_return(*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000113">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0ac04ea07b8fa82f006a1c7ca8aca27d"></a><!-- doxytag: member="SigC::slot" ref="g0ac04ea07b8fa82f006a1c7ca8aca27d" args="(T_return(*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;T_return, T_arg1,T_arg2&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000112">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfacca4d95320191460b14c9e21852894"></a><!-- doxytag: member="SigC::slot" ref="gfacca4d95320191460b14c9e21852894" args="(T_return(*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;T_return, T_arg1&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000111">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g259877f1c067ad10514f07687f337f8b"></a><!-- doxytag: member="SigC::slot" ref="g259877f1c067ad10514f07687f337f8b" args="(T_return(*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;T_return&gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000110">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">sigc::ptr_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc47a32cf4be8bd49a9d1beef1e398f69"></a><!-- doxytag: member="SigC::slot" ref="gc47a32cf4be8bd49a9d1beef1e398f69" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g88e87cb153a459d61776de5dfcda3677"></a><!-- doxytag: member="SigC::slot" ref="g88e87cb153a459d61776de5dfcda3677" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga1bb9d6796c4e6c072cd83a9118307b9"></a><!-- doxytag: member="SigC::slot" ref="ga1bb9d6796c4e6c072cd83a9118307b9" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000091">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g82d05033e2b2bee1ce03b1381c12da6b"></a><!-- doxytag: member="SigC::slot" ref="g82d05033e2b2bee1ce03b1381c12da6b" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000090">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5dbe067d6c701ea6cacff393f9f240ba"></a><!-- doxytag: member="SigC::slot" ref="g5dbe067d6c701ea6cacff393f9f240ba" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000089">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8fab160f730b83efbd9a74a24106a95b"></a><!-- doxytag: member="SigC::slot" ref="g8fab160f730b83efbd9a74a24106a95b" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt; T_return, T_arg1, T_arg2 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000088">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g107343642e204fb11d430487da95f832"></a><!-- doxytag: member="SigC::slot" ref="g107343642e204fb11d430487da95f832" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt; T_return, T_arg1 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9bca6dad79e9b0cccb8550831324c06c"></a><!-- doxytag: member="SigC::slot" ref="g9bca6dad79e9b0cccb8550831324c06c" args="(const T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)() const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt; T_return &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">const T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga6cd5deb8723357f578c5f57b2079a4c"></a><!-- doxytag: member="SigC::slot" ref="ga6cd5deb8723357f578c5f57b2079a4c" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9f2487af1f489d5c39e019e05b579d52"></a><!-- doxytag: member="SigC::slot" ref="g9f2487af1f489d5c39e019e05b579d52" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000084">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3c6d334b182a0a41a094f59d815a5367"></a><!-- doxytag: member="SigC::slot" ref="g3c6d334b182a0a41a094f59d815a5367" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000083">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdbee3c6f5bf882d3d0283a0226db86e3"></a><!-- doxytag: member="SigC::slot" ref="gdbee3c6f5bf882d3d0283a0226db86e3" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g86024098d53519ffa31aed081c347f07"></a><!-- doxytag: member="SigC::slot" ref="g86024098d53519ffa31aed081c347f07" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gcc3e1f6e658c464968947e19a188a180"></a><!-- doxytag: member="SigC::slot" ref="gcc3e1f6e658c464968947e19a188a180" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt; T_return, T_arg1, T_arg2 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3011c8f9efec0dc294994982f28fe520"></a><!-- doxytag: member="SigC::slot" ref="g3011c8f9efec0dc294994982f28fe520" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt; T_return, T_arg1 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge6e633fa340e3017871d86cb34367340"></a><!-- doxytag: member="SigC::slot" ref="ge6e633fa340e3017871d86cb34367340" args="(T_obj1 &amp;_A_obj, T_return(T_obj2::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj1, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt; T_return &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_obj1 &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a volatile method and an object instance.<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gce1eff0e298e8d7cc580b827834607c7"></a><!-- doxytag: member="SigC::slot" ref="gce1eff0e298e8d7cc580b827834607c7" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot7&lt; T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type Sigc::Slot7 that wraps a method. 
<p>
Creates a functor of type Sigc::Slot7 that wraps a const volatile method.<p>
Creates a functor of type Sigc::Slot7 that wraps a volatile method.<p>
Creates a functor of type Sigc::Slot7 that wraps a const method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6c1842450bb4b8b99357df9c4b00cb7c"></a><!-- doxytag: member="SigC::slot" ref="g6c1842450bb4b8b99357df9c4b00cb7c" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt; T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type Sigc::Slot6 that wraps a method. 
<p>
Creates a functor of type Sigc::Slot6 that wraps a const volatile method.<p>
Creates a functor of type Sigc::Slot6 that wraps a volatile method.<p>
Creates a functor of type Sigc::Slot6 that wraps a const method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g16e743368f8ee8868a2ebf185b75f056"></a><!-- doxytag: member="SigC::slot" ref="g16e743368f8ee8868a2ebf185b75f056" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt; T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3, T_arg4 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type Sigc::Slot5 that wraps a method. 
<p>
Creates a functor of type Sigc::Slot5 that wraps a const volatile method.<p>
Creates a functor of type Sigc::Slot5 that wraps a volatile method.<p>
Creates a functor of type Sigc::Slot5 that wraps a const method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g52eae75f30f433a7833e700ff25ac278"></a><!-- doxytag: member="SigC::slot" ref="g52eae75f30f433a7833e700ff25ac278" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt; T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type Sigc::Slot4 that wraps a method. 
<p>
Creates a functor of type Sigc::Slot4 that wraps a const volatile method.<p>
Creates a functor of type Sigc::Slot4 that wraps a volatile method.<p>
Creates a functor of type Sigc::Slot4 that wraps a const method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g82b240878388eeecbaa7c279d955e807"></a><!-- doxytag: member="SigC::slot" ref="g82b240878388eeecbaa7c279d955e807" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt; T_return, T_obj &amp;, T_arg1, T_arg2 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type Sigc::Slot3 that wraps a method. 
<p>
Creates a functor of type Sigc::Slot3 that wraps a const volatile method.<p>
Creates a functor of type Sigc::Slot3 that wraps a volatile method.<p>
Creates a functor of type Sigc::Slot3 that wraps a const method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000057">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3c952510d32d46cdfd2abf1128fc6d97"></a><!-- doxytag: member="SigC::slot" ref="g3c952510d32d46cdfd2abf1128fc6d97" args="(T_return(T_obj::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt; T_return, T_obj &amp;, T_arg1 &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type Sigc::Slot2 that wraps a method. 
<p>
Creates a functor of type Sigc::Slot2 that wraps a const volatile method.<p>
Creates a functor of type Sigc::Slot2 that wraps a volatile method.<p>
Creates a functor of type Sigc::Slot2 that wraps a const method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000056">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7246d6fa67ac9b66c913a35b93e18003"></a><!-- doxytag: member="SigC::slot" ref="g7246d6fa67ac9b66c913a35b93e18003" args="(T_return(T_obj::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt; T_return, T_obj &amp; &gt; SigC::slot           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type Sigc::Slot1 that wraps a method. 
<p>
Creates a functor of type Sigc::Slot1 that wraps a const volatile method.<p>
Creates a functor of type Sigc::Slot1 that wraps a volatile method.<p>
Creates a functor of type Sigc::Slot1 that wraps a const method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaaa4e86a7f5efa0d68360725a9035e3a"></a><!-- doxytag: member="SigC::slot_class" ref="gaaa4e86a7f5efa0d68360725a9035e3a" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd49affd5459e463a7a2fc038d4e6614b"></a><!-- doxytag: member="SigC::slot_class" ref="gd49affd5459e463a7a2fc038d4e6614b" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g635b197d134d20e6593c59b02b17b361"></a><!-- doxytag: member="SigC::slot_class" ref="g635b197d134d20e6593c59b02b17b361" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g606334d30de15d8a9b2a4b9b3bd23f68"></a><!-- doxytag: member="SigC::slot_class" ref="g606334d30de15d8a9b2a4b9b3bd23f68" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g09e1ce614750eb0dda785c2dcb0820a1"></a><!-- doxytag: member="SigC::slot_class" ref="g09e1ce614750eb0dda785c2dcb0820a1" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2c46b761223b969cb7a63bc60d9b8249"></a><!-- doxytag: member="SigC::slot_class" ref="g2c46b761223b969cb7a63bc60d9b8249" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt; T_return, T_arg1, T_arg2 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdc3f898be979b722b25a4ad24668e3ab"></a><!-- doxytag: member="SigC::slot_class" ref="gdc3f898be979b722b25a4ad24668e3ab" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt; T_return, T_arg1 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g75a6ff95d43b210d56f61264a56dc373"></a><!-- doxytag: member="SigC::slot_class" ref="g75a6ff95d43b210d56f61264a56dc373" args="(const T_obj &amp;_A_obj, T_return(T_obj::*_A_func)() const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt; T_return &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">const T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)() const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g622d6dbceeade9a3bb4faeff3e5d5a8a"></a><!-- doxytag: member="SigC::slot_class" ref="g622d6dbceeade9a3bb4faeff3e5d5a8a" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge46071e505c2519a76993d3262904ef1"></a><!-- doxytag: member="SigC::slot_class" ref="ge46071e505c2519a76993d3262904ef1" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g81a5adc40307650a5cd89d375e0987ac"></a><!-- doxytag: member="SigC::slot_class" ref="g81a5adc40307650a5cd89d375e0987ac" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gde17bd35ebbbdd4f7e81d64f723376f1"></a><!-- doxytag: member="SigC::slot_class" ref="gde17bd35ebbbdd4f7e81d64f723376f1" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd8d25c2c7dd544a6b2b280e7e62e6048"></a><!-- doxytag: member="SigC::slot_class" ref="gd8d25c2c7dd544a6b2b280e7e62e6048" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4c4822aeb56b6c748008226648791860"></a><!-- doxytag: member="SigC::slot_class" ref="g4c4822aeb56b6c748008226648791860" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt; T_return, T_arg1, T_arg2 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb1e0a43a66d818a52b29479c85531139"></a><!-- doxytag: member="SigC::slot_class" ref="gb1e0a43a66d818a52b29479c85531139" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt; T_return, T_arg1 &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g91af9b19917042109ebd6a01009dfcd7"></a><!-- doxytag: member="SigC::slot_class" ref="g91af9b19917042109ebd6a01009dfcd7" args="(T_obj &amp;_A_obj, T_return(T_obj::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt; T_return &gt; SigC::slot_class           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj::*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a method and an object instance. 
<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a volatile method and an object instance.<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun()</a> instead. </dd></dl>

</div>
</div><p>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
