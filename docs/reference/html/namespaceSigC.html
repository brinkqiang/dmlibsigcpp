<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: SigC Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.3 -->
<h1>SigC Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSigC_1_1retype__slot__functor.html">retype_slot_functor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSigC_1_1retype__slot__functor_3_01T__functor_00_01void_00_01T__type1_00_01T__type2_00_01T_79854cbbe71ab65c99245cc9113ce1bb.html">retype_slot_functor&lt;T_functor, void, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal0.html">Signal0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal1.html">Signal1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal2.html">Signal2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal3.html">Signal3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal4.html">Signal4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal5.html">Signal5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal6.html">Signal6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Signal7.html">Signal7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classSigC_1_1Signal7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classSigC_1_1Slot7.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
::<a class="el" href="structsigc_1_1connection.html">sigc::connection</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compat.html#g91f89ef3d156946196625c06de970957">Connection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convinience class for safe disconnection.  <a href="group__compat.html#g91f89ef3d156946196625c06de970957"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ::<a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#da96f27c4223c2c802ea830415739dd2">Object</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_bound1, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">inline::sigc::bind_functor&lt;-1,<br>
 T_functor,<br>
 typename::sigc::unwrap_reference<br>
&lt;T_bound1 &gt;::type&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#66994e20ebbb275ea2554c8d097cb019">bind</a> (const T_functor&amp; _A_functor, T_bound1 _A_b1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_bound1, class T_bound2, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">inline::sigc::bind_functor&lt;-1,<br>
 T_functor,<br>
 typename::sigc::unwrap_reference<br>
&lt; T_bound1 &gt;::type,<br>
 typename::sigc::unwrap_reference<br>
&lt;T_bound2 &gt;::type&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#67258c5dc81d130d8ec60e7211f5ae2b">bind</a> (const T_functor&amp; _A_functor, T_bound1 _A_b1, T_bound2 _A_b2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_bound1, class T_bound2, class T_bound3, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">inline::sigc::bind_functor&lt;-1,<br>
 T_functor,<br>
 typename::sigc::unwrap_reference<br>
&lt; T_bound1 &gt;::type,<br>
 typename::sigc::unwrap_reference<br>
&lt; T_bound2 &gt;::type,<br>
 typename::sigc::unwrap_reference<br>
&lt;T_bound3 &gt;::type&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#8a6caa87aa2bc64398e35f58856460a3">bind</a> (const T_functor&amp; _A_functor, T_bound1 _A_b1, T_bound2 _A_b2, T_bound3 _A_b3)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g91af9b19917042109ebd6a01009dfcd7">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g91af9b19917042109ebd6a01009dfcd7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gb1e0a43a66d818a52b29479c85531139">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a method and an object instance.  <a href="group__compat.html#gb1e0a43a66d818a52b29479c85531139"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g4c4822aeb56b6c748008226648791860">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g4c4822aeb56b6c748008226648791860"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gd8d25c2c7dd544a6b2b280e7e62e6048">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a method and an object instance.  <a href="group__compat.html#gd8d25c2c7dd544a6b2b280e7e62e6048"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gde17bd35ebbbdd4f7e81d64f723376f1">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a method and an object instance.  <a href="group__compat.html#gde17bd35ebbbdd4f7e81d64f723376f1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g81a5adc40307650a5cd89d375e0987ac">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g81a5adc40307650a5cd89d375e0987ac"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ge46071e505c2519a76993d3262904ef1">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a method and an object instance.  <a href="group__compat.html#ge46071e505c2519a76993d3262904ef1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g622d6dbceeade9a3bb4faeff3e5d5a8a">slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g622d6dbceeade9a3bb4faeff3e5d5a8a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g75a6ff95d43b210d56f61264a56dc373">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g75a6ff95d43b210d56f61264a56dc373"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gdc3f898be979b722b25a4ad24668e3ab">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#gdc3f898be979b722b25a4ad24668e3ab"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g2c46b761223b969cb7a63bc60d9b8249">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g2c46b761223b969cb7a63bc60d9b8249"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g09e1ce614750eb0dda785c2dcb0820a1">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g09e1ce614750eb0dda785c2dcb0820a1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g606334d30de15d8a9b2a4b9b3bd23f68">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g606334d30de15d8a9b2a4b9b3bd23f68"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g635b197d134d20e6593c59b02b17b361">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g635b197d134d20e6593c59b02b17b361"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gd49affd5459e463a7a2fc038d4e6614b">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#gd49affd5459e463a7a2fc038d4e6614b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gaaa4e86a7f5efa0d68360725a9035e3a">slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#gaaa4e86a7f5efa0d68360725a9035e3a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_hidden1, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a><br>
&lt; T_return,<br>
 T_hidden1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#37f9e0a394209a52f64c603867e35ac7">hide</a> (const <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a>&lt;T_return&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_hidden1, class T_return, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a><br>
&lt; T_return, T_arg1,<br>
 T_hidden1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#751ad3eca2e15331cdc95e0e7dda1ce6">hide</a> (const <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a>&lt;T_return, T_arg1&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_hidden1, class T_return, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a><br>
&lt; T_return, T_arg1,<br>
 T_arg2, T_hidden1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#99b1cae7d2609f0362d6e02b4e8e140a">hide</a> (const <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a>&lt;T_return, T_arg1, T_arg2&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a><br>
&lt; T_return, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_hidden1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#0d1a625cb9559fb6ec618b537c177e60">hide</a> (const <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a>&lt;T_return, T_arg1, T_arg2, T_arg3&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a><br>
&lt; T_return, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4, T_hidden1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#93c9a95a7cab87a2498e71ba2fd350d4">hide</a> (const <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a><br>
&lt; T_return, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4, T_arg5,<br>
 T_hidden1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#b92113d83a5166bd0e7ce5a557e4d3e5">hide</a> (const <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a><br>
&lt; T_return, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4, T_arg5,<br>
 T_arg6, T_hidden1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#6422b98b62aca7432b1764dc77ee3753">hide</a> (const <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt; T_return,<br>
 T_obj&amp; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g7246d6fa67ac9b66c913a35b93e18003">slot</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot1 that wraps a method.  <a href="group__compat.html#g7246d6fa67ac9b66c913a35b93e18003"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt; T_return,<br>
 T_obj&amp;, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g3c952510d32d46cdfd2abf1128fc6d97">slot</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot2 that wraps a method.  <a href="group__compat.html#g3c952510d32d46cdfd2abf1128fc6d97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g82b240878388eeecbaa7c279d955e807">slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot3 that wraps a method.  <a href="group__compat.html#g82b240878388eeecbaa7c279d955e807"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g52eae75f30f433a7833e700ff25ac278">slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot4 that wraps a method.  <a href="group__compat.html#g52eae75f30f433a7833e700ff25ac278"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g16e743368f8ee8868a2ebf185b75f056">slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot5 that wraps a method.  <a href="group__compat.html#g16e743368f8ee8868a2ebf185b75f056"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g6c1842450bb4b8b99357df9c4b00cb7c">slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot6 that wraps a method.  <a href="group__compat.html#g6c1842450bb4b8b99357df9c4b00cb7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt; T_return,<br>
 T_obj &amp;, T_arg1,<br>
 T_arg2, T_arg3,<br>
 T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gce1eff0e298e8d7cc580b827834607c7">slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot7 that wraps a method.  <a href="group__compat.html#gce1eff0e298e8d7cc580b827834607c7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ge6e633fa340e3017871d86cb34367340">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a method and an object instance.  <a href="group__compat.html#ge6e633fa340e3017871d86cb34367340"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g3011c8f9efec0dc294994982f28fe520">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g3011c8f9efec0dc294994982f28fe520"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gcc3e1f6e658c464968947e19a188a180">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a method and an object instance.  <a href="group__compat.html#gcc3e1f6e658c464968947e19a188a180"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g86024098d53519ffa31aed081c347f07">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g86024098d53519ffa31aed081c347f07"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gdbee3c6f5bf882d3d0283a0226db86e3">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a method and an object instance.  <a href="group__compat.html#gdbee3c6f5bf882d3d0283a0226db86e3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g3c6d334b182a0a41a094f59d815a5367">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g3c6d334b182a0a41a094f59d815a5367"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g9f2487af1f489d5c39e019e05b579d52">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a method and an object instance.  <a href="group__compat.html#g9f2487af1f489d5c39e019e05b579d52"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ga6cd5deb8723357f578c5f57b2079a4c">slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a method and an object instance.  <a href="group__compat.html#ga6cd5deb8723357f578c5f57b2079a4c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g9bca6dad79e9b0cccb8550831324c06c">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g9bca6dad79e9b0cccb8550831324c06c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g107343642e204fb11d430487da95f832">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g107343642e204fb11d430487da95f832"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g8fab160f730b83efbd9a74a24106a95b">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g8fab160f730b83efbd9a74a24106a95b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g5dbe067d6c701ea6cacff393f9f240ba">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g5dbe067d6c701ea6cacff393f9f240ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g82d05033e2b2bee1ce03b1381c12da6b">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g82d05033e2b2bee1ce03b1381c12da6b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#ga1bb9d6796c4e6c072cd83a9118307b9">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#ga1bb9d6796c4e6c072cd83a9118307b9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g88e87cb153a459d61776de5dfcda3677">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#g88e87cb153a459d61776de5dfcda3677"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gc47a32cf4be8bd49a9d1beef1e398f69">slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that encapsulates a const method and an object instance.  <a href="group__compat.html#gc47a32cf4be8bd49a9d1beef1e398f69"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_return, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#ae7d981c8a23852723ab6f1df12b967c">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structSigC_1_1retype__slot__functor.html">retype_slot_functor</a>&lt;T_functor, T_return, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_ret&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#a0c37debfecd9c8a3f639ccc868bfeb2">retype</a> (const <a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_ret&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_ret, class T_type1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#d4c7e60f2501628a42e4f2c40bcdf85a">retype</a> (const <a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_ret, T_type1&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_ret, class T_type1, class T_type2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#e91bf2cfdcf977b8c7b6fb8201b24988">retype</a> (const <a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt;T_ret, T_type1, T_type2&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_ret, class T_type1, class T_type2, class T_type3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#b4bf1daead1827a280dfa23ed30a5687">retype</a> (const <a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt;T_ret, T_type1, T_type2, T_type3&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#23f0b219b11c9d3eb413439f273cfbdc">retype</a> (const <a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt;T_ret, T_type1, T_type2, T_type3, T_type4&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#ce137a3c7382a38891cc85d37be2c170">retype</a> (const <a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt;T_ret, T_type1, T_type2, T_type3, T_type4, T_type5&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#759ec21a6254910426e7a8e98039dd40">retype</a> (const <a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt;T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSigC.html#587f8d8e2d3807e6cba56598ed9ebcde">retype</a> (const <a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt;T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7&gt;&amp; _A_slot)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g259877f1c067ad10514f07687f337f8b">slot</a> (T_return(* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot0</a> that wraps an existing non-member function.  <a href="group__compat.html#g259877f1c067ad10514f07687f337f8b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gfacca4d95320191460b14c9e21852894">slot</a> (T_return(* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot1</a> that wraps an existing non-member function.  <a href="group__compat.html#gfacca4d95320191460b14c9e21852894"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt; T_return,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g0ac04ea07b8fa82f006a1c7ca8aca27d">slot</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot2</a> that wraps an existing non-member function.  <a href="group__compat.html#g0ac04ea07b8fa82f006a1c7ca8aca27d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g642ee7f310005080070b485ac453f141">slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot3</a> that wraps an existing non-member function.  <a href="group__compat.html#g642ee7f310005080070b485ac453f141"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g239f7cb0854b6174de6303c5b0df153d">slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot4</a> that wraps an existing non-member function.  <a href="group__compat.html#g239f7cb0854b6174de6303c5b0df153d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gc4b3fe13ba71b42b8013a8384b5c4d97">slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot5</a> that wraps an existing non-member function.  <a href="group__compat.html#gc4b3fe13ba71b42b8013a8384b5c4d97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#gf525841f56ed2339c2fb64c7c77ffa44">slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot6</a> that wraps an existing non-member function.  <a href="group__compat.html#gf525841f56ed2339c2fb64c7c77ffa44"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt; T_return,<br>
 T_arg1, T_arg2,<br>
 T_arg3, T_arg4,<br>
 T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compat.html#g2d178de73e58532c261c79434eb80efb">slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html" title="Converts an arbitrary functor to a unified type which is opaque.">SigC::Slot7</a> that wraps an existing non-member function.  <a href="group__compat.html#g2d178de73e58532c261c79434eb80efb"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="da96f27c4223c2c802ea830415739dd2"></a><!-- doxytag: member="SigC::Object" ref="da96f27c4223c2c802ea830415739dd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> <a class="el" href="structsigc_1_1trackable.html">SigC::Object</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8a6caa87aa2bc64398e35f58856460a3"></a><!-- doxytag: member="SigC::bind" ref="8a6caa87aa2bc64398e35f58856460a3" args="(const T_functor &amp;_A_functor, T_bound1 _A_b1, T_bound2 _A_b2, T_bound3 _A_b3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_bound1, class T_bound2, class T_bound3, class T_functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::sigc::bind_functor&lt;-1, T_functor, typename ::<a class="el" href="structsigc_1_1unwrap__reference.html">sigc::unwrap_reference</a>&lt;T_bound1&gt;::type, typename ::<a class="el" href="structsigc_1_1unwrap__reference.html">sigc::unwrap_reference</a>&lt;T_bound2&gt;::type, typename ::<a class="el" href="structsigc_1_1unwrap__reference.html">sigc::unwrap_reference</a>&lt;T_bound3&gt;::type&gt; SigC::bind           </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_bound1&nbsp;</td>
          <td class="paramname"> <em>_A_b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_bound2&nbsp;</td>
          <td class="paramname"> <em>_A_b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_bound3&nbsp;</td>
          <td class="paramname"> <em>_A_b3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="67258c5dc81d130d8ec60e7211f5ae2b"></a><!-- doxytag: member="SigC::bind" ref="67258c5dc81d130d8ec60e7211f5ae2b" args="(const T_functor &amp;_A_functor, T_bound1 _A_b1, T_bound2 _A_b2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_bound1, class T_bound2, class T_functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::sigc::bind_functor&lt;-1, T_functor, typename ::<a class="el" href="structsigc_1_1unwrap__reference.html">sigc::unwrap_reference</a>&lt;T_bound1&gt;::type, typename ::<a class="el" href="structsigc_1_1unwrap__reference.html">sigc::unwrap_reference</a>&lt;T_bound2&gt;::type&gt; SigC::bind           </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_bound1&nbsp;</td>
          <td class="paramname"> <em>_A_b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_bound2&nbsp;</td>
          <td class="paramname"> <em>_A_b2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="66994e20ebbb275ea2554c8d097cb019"></a><!-- doxytag: member="SigC::bind" ref="66994e20ebbb275ea2554c8d097cb019" args="(const T_functor &amp;_A_functor, T_bound1 _A_b1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_bound1, class T_functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::sigc::bind_functor&lt;-1, T_functor, typename ::<a class="el" href="structsigc_1_1unwrap__reference.html">sigc::unwrap_reference</a>&lt;T_bound1&gt;::type&gt; SigC::bind           </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_bound1&nbsp;</td>
          <td class="paramname"> <em>_A_b1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6422b98b62aca7432b1764dc77ee3753"></a><!-- doxytag: member="SigC::hide" ref="6422b98b62aca7432b1764dc77ee3753" args="(const SigC::Slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6, T_hidden1&gt; SigC::hide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b92113d83a5166bd0e7ce5a557e4d3e5"></a><!-- doxytag: member="SigC::hide" ref="b92113d83a5166bd0e7ce5a557e4d3e5" args="(const SigC::Slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_hidden1, T_hidden2&gt; SigC::hide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="93c9a95a7cab87a2498e71ba2fd350d4"></a><!-- doxytag: member="SigC::hide" ref="93c9a95a7cab87a2498e71ba2fd350d4" args="(const SigC::Slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_hidden1, T_hidden2&gt; SigC::hide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0d1a625cb9559fb6ec618b537c177e60"></a><!-- doxytag: member="SigC::hide" ref="0d1a625cb9559fb6ec618b537c177e60" args="(const SigC::Slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_hidden1, class T_return, class T_arg1, class T_arg2, class T_arg3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_hidden1, T_hidden2&gt; SigC::hide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a>&lt;T_return, T_arg1, T_arg2, T_arg3&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="99b1cae7d2609f0362d6e02b4e8e140a"></a><!-- doxytag: member="SigC::hide" ref="99b1cae7d2609f0362d6e02b4e8e140a" args="(const SigC::Slot2&lt; T_return, T_arg1, T_arg2 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_hidden1, class T_return, class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a>&lt;T_return, T_arg1, T_arg2, T_hidden1, T_hidden2&gt; SigC::hide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a>&lt;T_return, T_arg1, T_arg2&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="751ad3eca2e15331cdc95e0e7dda1ce6"></a><!-- doxytag: member="SigC::hide" ref="751ad3eca2e15331cdc95e0e7dda1ce6" args="(const SigC::Slot1&lt; T_return, T_arg1 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_hidden1, class T_return, class T_arg1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a>&lt;T_return, T_arg1, T_hidden1, T_hidden2&gt; SigC::hide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a>&lt;T_return, T_arg1&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="37f9e0a394209a52f64c603867e35ac7"></a><!-- doxytag: member="SigC::hide" ref="37f9e0a394209a52f64c603867e35ac7" args="(const SigC::Slot0&lt; T_return &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_hidden1, class T_return&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a>&lt;T_return, T_hidden1, T_hidden2&gt; SigC::hide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a>&lt;T_return&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="587f8d8e2d3807e6cba56598ed9ebcde"></a><!-- doxytag: member="SigC::retype" ref="587f8d8e2d3807e6cba56598ed9ebcde" args="(const Slot7&lt; T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot7.html">Slot7</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot7&lt; T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="759ec21a6254910426e7a8e98039dd40"></a><!-- doxytag: member="SigC::retype" ref="759ec21a6254910426e7a8e98039dd40" args="(const Slot6&lt; T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot6.html">Slot6</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot6&lt; T_ret, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ce137a3c7382a38891cc85d37be2c170"></a><!-- doxytag: member="SigC::retype" ref="ce137a3c7382a38891cc85d37be2c170" args="(const Slot5&lt; T_ret, T_type1, T_type2, T_type3, T_type4, T_type5 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot5.html">Slot5</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot5&lt; T_ret, T_type1, T_type2, T_type3, T_type4, T_type5 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="23f0b219b11c9d3eb413439f273cfbdc"></a><!-- doxytag: member="SigC::retype" ref="23f0b219b11c9d3eb413439f273cfbdc" args="(const Slot4&lt; T_ret, T_type1, T_type2, T_type3, T_type4 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_ret, class T_type1, class T_type2, class T_type3, class T_type4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot4.html">Slot4</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot4&lt; T_ret, T_type1, T_type2, T_type3, T_type4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b4bf1daead1827a280dfa23ed30a5687"></a><!-- doxytag: member="SigC::retype" ref="b4bf1daead1827a280dfa23ed30a5687" args="(const Slot3&lt; T_ret, T_type1, T_type2, T_type3 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_ret, class T_type1, class T_type2, class T_type3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot3.html">Slot3</a>&lt;T_return, T_arg1,T_arg2,T_arg3&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot3&lt; T_ret, T_type1, T_type2, T_type3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e91bf2cfdcf977b8c7b6fb8201b24988"></a><!-- doxytag: member="SigC::retype" ref="e91bf2cfdcf977b8c7b6fb8201b24988" args="(const Slot2&lt; T_ret, T_type1, T_type2 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_ret, class T_type1, class T_type2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot2.html">Slot2</a>&lt;T_return, T_arg1,T_arg2&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot2&lt; T_ret, T_type1, T_type2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d4c7e60f2501628a42e4f2c40bcdf85a"></a><!-- doxytag: member="SigC::retype" ref="d4c7e60f2501628a42e4f2c40bcdf85a" args="(const Slot1&lt; T_ret, T_type1 &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_ret, class T_type1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot1.html">Slot1</a>&lt;T_return, T_arg1&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot1&lt; T_ret, T_type1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a0c37debfecd9c8a3f639ccc868bfeb2"></a><!-- doxytag: member="SigC::retype" ref="a0c37debfecd9c8a3f639ccc868bfeb2" args="(const Slot0&lt; T_ret &gt; &amp;_A_slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_ret&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSigC_1_1Slot0.html">Slot0</a>&lt;T_return&gt; SigC::retype           </td>
          <td>(</td>
          <td class="paramtype">const Slot0&lt; T_ret &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_slot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ae7d981c8a23852723ab6f1df12b967c"></a><!-- doxytag: member="SigC::visit_each" ref="ae7d981c8a23852723ab6f1df12b967c" args="(const T_action &amp;_A_action, const retype_slot_functor&lt; T_functor, T_return, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_functor, class T_return, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SigC::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const retype_slot_functor&lt; T_functor, T_return, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
