<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: Functors</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.3 -->
<h1>Functors</h1>
<p>
<div class="dynheader">
Collaboration diagram for Functors:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__functors.png" border="0" alt="" usemap="#group____functors_map">
<map name="group____functors_map">
<area shape="rect" href="group__mem__fun.html" title="mem_fun() is used to convert a pointer to a method to a functor." alt="" coords="124,5,204,32"><area shape="rect" href="group__slot.html" title="Slots are type&#45;safe representations of callback methods and functions." alt="" coords="140,56,188,83"><area shape="rect" href="group__ptr__fun.html" title="ptr_fun() is used to convert a pointer to a function to a functor." alt="" coords="129,107,199,133"></map></td></tr></table></center>
</div>
Functors are copyable types that define operator()().  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mem__fun.html">mem_fun()</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> is used to convert a pointer to a method to a functor. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html">ptr_fun()</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">ptr_fun()</a> is used to convert a pointer to a function to a functor. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slot.html">Slots</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slots are type-safe representations of callback methods and functions. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">sigc::functor_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1functor__base.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functors.html#g93b6ee8815d90adccfdceed72bcda577">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you want to mix functors from a different library with libsigc++ and these functors define <code>result_type</code> simply use this macro inside namespace <a class="el" href="namespacesigc.html">sigc</a> like so:.  <a href="#g93b6ee8815d90adccfdceed72bcda577"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functors.html#g7a6f5575dc0b0ea896889c782721f6be">SIGC_FUNCTOR_TRAIT</a>(T_functor, T_return)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you want to mix functors from a different library with libsigc++ and these functors don't define <code>result_type</code> use this macro inside namespace <a class="el" href="namespacesigc.html">sigc</a> to expose the return type of the functors like so:.  <a href="#g7a6f5575dc0b0ea896889c782721f6be"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functors.html#gdab29aed05524743da16319da4430541">sigc::visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor.  <a href="#gdab29aed05524743da16319da4430541"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_action, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functors.html#g5c455eda401dee43de931c24ad45d445">sigc::visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type.  <a href="#g5c455eda401dee43de931c24ad45d445"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functors are copyable types that define operator()(). 
<p>
Types that define operator()() overloads with different return types are referred to as multi-type functors. Multi-type functors are only partly supported in libsigc++.<p>
Closures are functors that store all information needed to invoke a callback from operator()().<p>
Adaptors are functors that alter the signature of a functor's operator()().<p>
libsigc++ defines numerous functors, closures and adaptors. Since libsigc++ is a callback libaray, most functors are also closures. The documentation doesn't distinguish between functors and closures.<p>
The basic functor types libsigc++ provides are created with <a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">ptr_fun()</a> and <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> and can be converted into slots implicitly. The set of adaptors that ships with libsigc++ is documented in the equally named module. <hr><h2>Define Documentation</h2>
<a class="anchor" name="g7a6f5575dc0b0ea896889c782721f6be"></a><!-- doxytag: member="functor_trait.h::SIGC_FUNCTOR_TRAIT" ref="g7a6f5575dc0b0ea896889c782721f6be" args="(T_functor, T_return)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTOR_TRAIT          </td>
          <td>(</td>
          <td class="paramtype">T_functor,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;&gt;                                    \
<span class="keyword">struct </span>functor_trait&lt;T_functor,false&gt;          \
{                                              \
  <span class="keyword">typedef</span> T_return result_type;                \
  <span class="keyword">typedef</span> T_functor functor_type;              \
};
</pre></div>If you want to mix functors from a different library with libsigc++ and these functors don't define <code>result_type</code> use this macro inside namespace <a class="el" href="namespacesigc.html">sigc</a> to expose the return type of the functors like so:. 
<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">namespace </span>sigc {
   <a class="code" href="group__functors.html#g7a6f5575dc0b0ea896889c782721f6be" title="If you want to mix functors from a different library with libsigc++ and these functors...">SIGC_FUNCTOR_TRAIT</a>(first_functor_type, return_type_of_first_functor_type)
   <a class="code" href="group__functors.html#g7a6f5575dc0b0ea896889c782721f6be" title="If you want to mix functors from a different library with libsigc++ and these functors...">SIGC_FUNCTOR_TRAIT</a>(second_functor_type, return_type_of_second_functor_type)
   ...
 }
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g93b6ee8815d90adccfdceed72bcda577"></a><!-- doxytag: member="functor_trait.h::SIGC_FUNCTORS_HAVE_RESULT_TYPE" ref="g93b6ee8815d90adccfdceed72bcda577" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTORS_HAVE_RESULT_TYPE          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T_functor&gt;                             \
<span class="keyword">struct </span>functor_trait&lt;T_functor,false&gt;                  \
{                                                      \
  <span class="keyword">typedef</span> <span class="keyword">typename</span> T_functor::result_type result_type; \
  <span class="keyword">typedef</span> T_functor functor_type;                      \
};
</pre></div>If you want to mix functors from a different library with libsigc++ and these functors define <code>result_type</code> simply use this macro inside namespace <a class="el" href="namespacesigc.html">sigc</a> like so:. 
<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">namespace </span>sigc { <a class="code" href="group__functors.html#g93b6ee8815d90adccfdceed72bcda577" title="If you want to mix functors from a different library with libsigc++ and these functors...">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a> }
</pre></div> 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gdab29aed05524743da16319da4430541"></a><!-- doxytag: member="sigc::visit_each" ref="gdab29aed05524743da16319da4430541" args="(const T_action &amp;_A_action, const T_functor &amp;_A_functor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_functor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs a functor on each of the targets of a functor. 
<p>
All unknown types just call <em>_A_action</em> on them. Add overloads that specialize the <em>T_functor</em> argument for your own functor types, so that subobjects get visited. This is needed to enable auto-disconnection support for your functor types.<p>
<dl class="user" compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>some_functor
   {
     <span class="keywordtype">void</span> operator()() {}
     some_possibly_sigc_trackable_derived_type some_data_member;
     some_other_functor_type some_other_functor;
   }

   <span class="keyword">namespace </span>sigc
   {
     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T_action&gt;
     <span class="keywordtype">void</span> <a class="code" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c" title="Performs a functor on each of the targets of a functor.">visit_each</a>(<span class="keyword">const</span> T_action&amp; _A_action,
                     <span class="keyword">const</span> some_functor&amp; _A_target)
     {
       <a class="code" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c" title="Performs a functor on each of the targets of a functor.">visit_each</a>(_A_action, _A_target.some_data_member);
       <a class="code" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c" title="Performs a functor on each of the targets of a functor.">visit_each</a>(_A_action, _A_target.some_other_functor);
     }
   }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5c455eda401dee43de931c24ad45d445"></a><!-- doxytag: member="sigc::visit_each_type" ref="g5c455eda401dee43de931c24ad45d445" args="(const T_action &amp;_A_action, const T_functor &amp;_A_functor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type, class T_action, class T_functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each_type           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_functor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs a functor on each of the targets of a functor limited to a restricted type. 
<p>

</div>
</div><p>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
